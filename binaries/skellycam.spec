# skellycam.spec

# NOTE - a .spec file is a Python script that PyInstaller uses to build the executable. It is a configuration file that tells PyInstaller what to include in the executable and how to build it. The .spec file is generated by PyInstaller when you run the pyinstaller command with the --onefile option. You can also create a .spec file manually and customize it to include additional files, data, and hidden imports.
# HINT - Tell your IDE to treat *.spec files as Python files to get syntax highlighting and code completion (just ignore the warnings about unknown imports).

import platform
import sys
from pathlib import Path
import numpy as np

from PyInstaller.utils.hooks import collect_submodules

# Define paths to important directories and files
PACKAGE_ROOT_PATH = str(Path(sys.argv[0]).resolve().parent.parent)

OUTPUT_DIST_PATH = str(Path(PACKAGE_ROOT_PATH) / 'dist')
WORK_BUILD_PATH = str(Path(PACKAGE_ROOT_PATH) / 'build')

SHARED_RESOURCES_PATH = Path(PACKAGE_ROOT_PATH) / 'shared' / 'skellycam-logo'
SKELLYCAM_SVG_PATH = str(SHARED_RESOURCES_PATH / 'skellycam-logo.svg')
SKELLYCAM_ICO_PATH = str(SHARED_RESOURCES_PATH / 'skellycam-favicon.ico')
SKELLYCAM_MAIN_PATH = str(Path(PACKAGE_ROOT_PATH) / 'skellycam' / '__main__.py')
UI_HTML_PATH = str(Path(PACKAGE_ROOT_PATH) / 'skellycam' / 'api' / 'http' / 'ui' / 'ui.html')


def get_target_triple() -> str:
    """
    Determine the system target triple based on the platform and architecture.

    A target triple is a string that uniquely identifies the platform and
    architecture for which the executable is built. It typically includes
    the operating system and the architecture (e.g., 'windows-amd64').

    Including the target triple in the executable name helps in distinguishing
    between different builds of the application, making it clear which platform
    and architecture each executable is intended for.

    Returns:
        str: The target triple (e.g., 'windows-amd64').
    """
    system = platform.system().lower()
    machine = platform.machine().lower()
    return f"{system}-{machine}"


# Determine the executable base name with the target triple
target_triple = get_target_triple()
executable_base_name = f'skellycam-GUI-{target_triple}'

# Analysis step: Collect all necessary scripts, data files, and hidden imports
a = Analysis(
    [SKELLYCAM_MAIN_PATH],  # Entry point of the application
    pathex=[PACKAGE_ROOT_PATH],  # Paths to search for imports
    binaries=[
        (str(Path(np.__path__[0]) / 'core' / '*.dll'), 'numpy/core')  # Include NumPy DLLs
    ],  # List of binary files to include
    datas=[
        (SKELLYCAM_SVG_PATH, 'shared/skellycam-logo'),  # Include SVG logo
        (UI_HTML_PATH, 'skellycam/api/http/ui'),  # Include HTML UI file
        (SKELLYCAM_ICO_PATH, 'shared/skellycam-logo')  # Include ICO favicon
    ],
    hiddenimports=collect_submodules('numpy'),  # Automatically collect hidden imports for NumPy
    hookspath=[],  # Paths to additional hook files
    runtime_hooks=[],  # Scripts to run at startup
    excludes=[],  # List of modules to exclude from the package
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=None,
    noarchive=False
)

# PYZ step: Create a Python archive from the collected scripts and data
pyz = PYZ(a.pure, a.zipped_data, cipher=None)

# EXE step: Build the executable
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name=executable_base_name,  # Name of the executable with target triple
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,  # Use UPX to compress the executable
    upx_exclude=[],
    runtime_tmpdir=None,
    console=True,  # Set to False if you don't want a console window
    icon=SKELLYCAM_ICO_PATH,  # Icon for the executable
    onefile=True
)

# COLLECT step: Collect all files into the final distribution directory
coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name=executable_base_name
)
